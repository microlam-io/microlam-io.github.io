

<div class="full-width-bg component">
  <div class="grid-wrapper">
    <div class="width-3-12 width-12-12-m">
    <img src="{{site.baseurl}}/assets/images/powered-by-aws.png">
    </div>
    <div class="width-9-12 width-12-12-m">
      <p class="intropara">"Modern applications are built serverless-first, a strategy that prioritizes the adoption of serverless services, so you can increase agility throughout your application stack. Weâ€™ve developed serverless services for all three layers of your stack: compute, integration, and data stores." quoted from <a href="https://aws.amazon.com/serverless/">AWS Serverless page</a>. Among them you find:</p>
      <img src="{{site.baseurl}}/assets/images/lambda.jpeg" alt="AWS Lambda"">
      <img src="{{site.baseurl}}/assets/images/api-gateway.jpeg" alt="AWS API-Gateway"">
      <img src="{{site.baseurl}}/assets/images/dynamodb.jpeg" alt="AWS DynamoDB"">
      <img src="{{site.baseurl}}/assets/images/s3.jpeg" alt="AWS S3"">
    </div>
    <div class="width-12-12 width-12-12-m">
      <h2>Developping for AWS Services</h2>
        <p>AWS Services are really powerful but are offering so many options that you can feel lost with all the details and possibilities. You may have also several ways to get the same thing. By focusing on AWS, Microlam is able to give you the experience for developing on AWS.</p>

        <h2>AWS SDK for Java 2.x</h2>
        <p>Microlam add a layer above the <a href="https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/home.html">AWS SDK for Java 2.x</a> simplifying testing, developping and deploying.</p>
  
        <h2>AWS Lambda</h2>
        <p>AWS Lambda supports several Runtime among: Java 11, Custom, or Container based. Microlam helps you develop for Java 11 or Java 17 then convert your App to Custom, and eventually to use containers.</p>

        <h2>First-Class Support for GraalVM Native Images</h2>
        <p>GraalVM Native Executable support is an essential part of the design for Microlam. When an application is compiled down to a native executable, it starts much faster and can run with a much smaller heap than a standard JVM. The native compiler uses aggressive dead-code elimination techniques to only embed the parts of the JVM and classes that are absolutely required by your application. Microlam makes building optimized native executables plain easy, notably by providing you a way to generate the configuration automatically to fine-tune the compilation.</p>
    </div>
  </div>
</div>
